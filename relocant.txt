-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A PostgreSQL migration CLI tool and library
--   
--   relocant documentation is at <a>https://github.com/supki/relocant</a>
@package relocant
@version 1.0.0


-- | This module deals with getting the moment of time something's
--   happened.
module Relocant.At

-- | The moment of time something's happened. (This is a newtype over
--   <a>ZonedTime</a>)
data At

-- | Format <a>At</a> as a <a>String</a>, using the usual <i>time</i>
--   format string.
format :: String -> At -> String

-- | Get current time.
now :: IO At

-- | Get '1970-01-01 00:00:00 UTC' as an <a>At</a>.
epoch :: At
instance Database.PostgreSQL.Simple.ToField.ToField Relocant.At.At
instance Database.PostgreSQL.Simple.FromField.FromField Relocant.At.At
instance Data.Aeson.Types.ToJSON.ToJSON Relocant.At.At
instance GHC.Show.Show Relocant.At.At
instance GHC.Classes.Eq Relocant.At.At


-- | This module manages PostgreSQL connections and <i>relocant</i>'s DB
--   schema.
module Relocant.DB

-- | PostgreSQL connection string. (This is a newtype over
--   <a>ByteString</a>)
--   
--   for syntax, see:
--   <a>https://hackage.haskell.org/package/postgresql-simple/docs/Database-PostgreSQL-Simple.html#v:connectPostgreSQL</a>
data ConnectionString

-- | <i>relocant's</i> migration table name.
data Table

-- | The default table name, which is "public.relocant_migration".
defaultTable :: Table

-- | Connect to the DB using the given <a>ConnectionString</a> and
--   initialize the migrations table.
connect :: ConnectionString -> Table -> IO Connection

-- | Initialize the migrations table.
init :: Connection -> Table -> IO ()

-- | Use <i>pg_advisory_{lock,unlock}</i> to restrict access to the
--   migrations table. The given table is used to generate the lock's ID,
--   so that in the unlikely case where you have multiple migrations tables
--   in your database you can lock them separately.
withLock :: Table -> Connection -> IO a -> IO a

-- | A non-blocking version of <a>withLock</a>. <a>True</a> is passed to
--   the callback if the lock was successfully acquired, <a>False</a>
--   otherwise.
withTryLock :: Table -> Connection -> (Bool -> IO a) -> IO a

-- | Use <i>pg_advisory_lock</i> to lock the database, restricting access
--   to the migrations table. The given table is used to generate the
--   lock's ID, so that in the unlikely case where you have multiple
--   migrations tables in your database you can lock them separately.
lock :: Table -> Connection -> IO ()

-- | A non-blocking version of <a>lock</a>. Returns <a>True</a> if the lock
--   was successfully acquired, <a>False</a> otherwise.
tryLock :: Table -> Connection -> IO Bool

-- | Use <i>pg_advisory_unlock</i> to unlock the database.
unlock :: Table -> Connection -> IO Bool
dumpSchema :: IO ()
instance Data.String.IsString Relocant.DB.ConnectionString
instance GHC.Classes.Eq Relocant.DB.ConnectionString
instance GHC.Show.Show Relocant.DB.ConnectionString
instance Data.Aeson.Types.ToJSON.ToJSON Relocant.DB.ConnectionString


-- | This module deals with timing actions.
module Relocant.Duration

-- | How long something took, in seconds. Use <a>mempty</a> for a 0 seconds
--   <a>Duration</a>.
newtype Duration
Duration :: Double -> Duration

-- | Time an action.
measure :: IO a -> IO (Duration, a)

-- | Time an action and ignore its result.
measure_ :: IO x -> IO Duration
instance Database.PostgreSQL.Simple.ToField.ToField Relocant.Duration.Duration
instance Database.PostgreSQL.Simple.FromField.FromField Relocant.Duration.Duration
instance Data.Aeson.Types.ToJSON.ToJSON Relocant.Duration.Duration
instance Text.Printf.PrintfArg Relocant.Duration.Duration
instance GHC.Classes.Eq Relocant.Duration.Duration
instance GHC.Show.Show Relocant.Duration.Duration
instance GHC.Base.Semigroup Relocant.Duration.Duration
instance GHC.Base.Monoid Relocant.Duration.Duration


-- | This module deals with applied migrations and their records in the DB.
module Relocant.Applied

-- | An applied migration. Generally, it's created be either running a
--   migration <a>Script</a> with <a>apply</a> or getting the records from
--   the DB with <a>getApplied</a> or <a>getAppliedByID</a>.
data Applied
Applied :: ID -> Name -> Content -> At -> Duration -> Applied
[$sel:id:Applied] :: Applied -> ID
[$sel:name:Applied] :: Applied -> Name
[$sel:content:Applied] :: Applied -> Content
[$sel:appliedAt:Applied] :: Applied -> At

-- | how long it took to apply the migration script
[$sel:durationS:Applied] :: Applied -> Duration

-- | Retrieve all <a>Applied</a> migrations' records from the DB.
getApplied :: Table -> Connection -> IO [Applied]

-- | Retrieve the specific <a>Applied</a> migration's record from the DB.
getAppliedByID :: ID -> Table -> Connection -> IO (Maybe Applied)

-- | Record a successfully <a>Applied</a> migration.
record :: Applied -> Table -> Connection -> IO ()

-- | Delete all <a>Applied</a> migrations' records from the DB.
deleteAll :: Table -> Connection -> IO ()

-- | Delete the specific <a>Applied</a> migration's record from the DB.
deleteByID :: ID -> Table -> Connection -> IO Bool
instance GHC.Classes.Eq Relocant.Applied.Applied
instance GHC.Show.Show Relocant.Applied.Applied
instance Data.Aeson.Types.ToJSON.ToJSON Relocant.Applied.Applied
instance GHC.Records.HasField "bytes" Relocant.Applied.Applied Data.ByteString.Internal.Type.ByteString
instance GHC.Records.HasField "checksum" Relocant.Applied.Applied Relocant.Checksum.Checksum


-- | This module deals with migrations that haven't yet been applied.
module Relocant.Script

-- | A migration script. Most users would get them by running
--   <a>readScripts</a>, but those wanting a more fine-grained control
--   would use <a>readScript</a>.
data Script
Script :: ID -> Name -> Content -> Script

-- | if XXX-YYYY.sql is the whole filename, then XXX is the id; see
--   <a>parseFilePath</a>
[$sel:id:Script] :: Script -> ID

-- | if XXX-YYYY.sql is the whole filename, then XXX-YYYY is the name
[$sel:name:Script] :: Script -> Name
[$sel:content:Script] :: Script -> Content

-- | Read migration <a>Script</a>s from a directory. It only tries to read
--   paths ending with the <i>.sql</i> extension and doesn't recurse into
--   subdirectories.
--   
--   <i>Note</i>: the directory must exist
readScripts :: FilePath -> IO [Script]

-- | Read migration <a>Script</a>s from a file. Useful when you need a more
--   fine-grained control over which paths are read then what
--   <a>readScripts</a> provides.
readScript :: FilePath -> IO Script

-- | Run a <a>Script</a> against the database, get an <a>Applied</a>
--   migration back if successful.
apply :: Script -> Connection -> IO Applied

-- | Get an <a>Applied</a> migration from a <a>Script</a>, without running
--   it. This should not be normally used, but can be useful for fixing
--   checksums after cosmetics updates of migration <a>Script</a>s (such as
--   adding comments, for example).
markApplied :: Script -> IO Applied

-- | Get XXX as the <a>ID</a> and XXX-YYYY as the <a>Name</a> from
--   XXX-YYYY.sql
--   
--   Basically, the longest alphanumeric prefix of the basename is the
--   <a>ID</a>, and the basename is the <a>Name</a>.
parseFilePath :: FilePath -> (ID, Name)

-- | Get migration <a>Script</a>'s content and its checksum.
readContent :: FilePath -> IO Content
instance GHC.Classes.Eq Relocant.Script.Script
instance GHC.Show.Show Relocant.Script.Script
instance Data.Aeson.Types.ToJSON.ToJSON Relocant.Script.Script
instance GHC.Records.HasField "bytes" Relocant.Script.Script Data.ByteString.Internal.Type.ByteString
instance GHC.Records.HasField "checksum" Relocant.Script.Script Relocant.Checksum.Checksum


-- | A PostgreSQL migration library
module Relocant

-- | A migration script. Most users would get them by running
--   <a>readScripts</a>, but those wanting a more fine-grained control
--   would use <a>readScript</a>.
data Script
Script :: ID -> Name -> Content -> Script

-- | if XXX-YYYY.sql is the whole filename, then XXX is the id; see
--   <a>parseFilePath</a>
[$sel:id:Script] :: Script -> ID

-- | if XXX-YYYY.sql is the whole filename, then XXX-YYYY is the name
[$sel:name:Script] :: Script -> Name
[$sel:content:Script] :: Script -> Content

-- | Read migration <a>Script</a>s from a directory. It only tries to read
--   paths ending with the <i>.sql</i> extension and doesn't recurse into
--   subdirectories.
--   
--   <i>Note</i>: the directory must exist
readScripts :: FilePath -> IO [Script]

-- | Read migration <a>Script</a>s from a file. Useful when you need a more
--   fine-grained control over which paths are read then what
--   <a>readScripts</a> provides.
readScript :: FilePath -> IO Script

-- | PostgreSQL connection string. (This is a newtype over
--   <a>ByteString</a>)
--   
--   for syntax, see:
--   <a>https://hackage.haskell.org/package/postgresql-simple/docs/Database-PostgreSQL-Simple.html#v:connectPostgreSQL</a>
data ConnectionString

-- | Connect to the DB using the given <a>ConnectionString</a> and
--   initialize the migrations table.
connect :: ConnectionString -> Table -> IO Connection

-- | Use <i>pg_advisory_{lock,unlock}</i> to restrict access to the
--   migrations table. The given table is used to generate the lock's ID,
--   so that in the unlikely case where you have multiple migrations tables
--   in your database you can lock them separately.
withLock :: Table -> Connection -> IO a -> IO a

-- | A non-blocking version of <a>withLock</a>. <a>True</a> is passed to
--   the callback if the lock was successfully acquired, <a>False</a>
--   otherwise.
withTryLock :: Table -> Connection -> (Bool -> IO a) -> IO a

-- | An applied migration. Generally, it's created be either running a
--   migration <a>Script</a> with <a>apply</a> or getting the records from
--   the DB with <a>getApplied</a> or <a>getAppliedByID</a>.
data Applied
Applied :: ID -> Name -> Content -> At -> Duration -> Applied
[$sel:id:Applied] :: Applied -> ID
[$sel:name:Applied] :: Applied -> Name
[$sel:content:Applied] :: Applied -> Content
[$sel:appliedAt:Applied] :: Applied -> At

-- | how long it took to apply the migration script
[$sel:durationS:Applied] :: Applied -> Duration

-- | Migration <a>ID</a>.
data ID

-- | Migration <a>Name</a>.
data Name

-- | Migration content and its checksum.
data Content

-- | How long something took, in seconds. Use <a>mempty</a> for a 0 seconds
--   <a>Duration</a>.
data Duration

-- | <i>relocant's</i> migration table name.
data Table

-- | The default table name, which is "public.relocant_migration".
defaultTable :: Table

-- | Retrieve all <a>Applied</a> migrations' records from the DB.
getApplied :: Table -> Connection -> IO [Applied]

-- | Retrieve the specific <a>Applied</a> migration's record from the DB.
getAppliedByID :: ID -> Table -> Connection -> IO (Maybe Applied)

-- | Merge scripts and applied migrations, trying to discover
--   inconsistencies and/or migration scripts to apply.
merge :: [Applied] -> [Script] -> Merged

-- | A convenience function that gets all applied migrations' records from
--   the DB and merges them together with the migration scripts from a
--   given directory.
mergeAll :: Table -> Connection -> FilePath -> IO Merged

-- | The result of merging <a>Script</a>s and <a>Applied</a> migrations.
data Merged
Merged :: [Script] -> [Applied] -> [ContentMismatch] -> [Script] -> Merged

-- | A script that does not have a corresponding recorded migration, when
--   there is a recorded migration with a higher ID
[$sel:unrecorded:Merged] :: Merged -> [Script]

-- | A recorded migration that does not have a corresponding script
[$sel:scriptMissing:Merged] :: Merged -> [Applied]

-- | A recorded migration and a script have the same ID but different
--   content
[$sel:contentMismatch:Merged] :: Merged -> [ContentMismatch]

-- | An unapplied script that has a higher ID than any recorded migration
[$sel:unapplied:Merged] :: Merged -> [Script]

-- | The applied migration and its purported script differ in content.
data ContentMismatch
ContentMismatch :: Applied -> Script -> ContentMismatch
[$sel:expected:ContentMismatch] :: ContentMismatch -> Applied
[$sel:butGot:ContentMismatch] :: ContentMismatch -> Script

-- | No problems have been discovered after the merge.
canApply :: Merged -> Bool

-- | No problems have been discovered after the merge, and there are no
--   migration scripts to apply.
converged :: Merged -> Bool

-- | Run a <a>Script</a> against the database, get an <a>Applied</a>
--   migration back if successful.
apply :: Script -> Connection -> IO Applied

-- | Record a successfully <a>Applied</a> migration.
record :: Applied -> Table -> Connection -> IO ()
data () => Connection

-- | Execute an action inside a SQL transaction.
--   
--   This function initiates a transaction with a "<tt>begin
--   transaction</tt>" statement, then executes the supplied action. If the
--   action succeeds, the transaction will be completed with <a>commit</a>
--   before this function returns.
--   
--   If the action throws <i>any</i> kind of exception (not just a
--   PostgreSQL-related exception), the transaction will be rolled back
--   using <a>rollback</a>, then the exception will be rethrown.
--   
--   For nesting transactions, see <a>withSavepoint</a>.
withTransaction :: Connection -> IO a -> IO a
